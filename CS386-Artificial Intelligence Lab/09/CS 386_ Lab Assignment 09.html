
<!-- saved from url=(0098)https://www.cse.iitb.ac.in/~shivaram/teaching/cs344+386-s2017/resources/la-9/lab-assignment-9.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<link rel="stylesheet" type="text/css" href="./CS 386_ Lab Assignment 09_files/style.css">
<title>CS 386: Lab Assignment 09</title>
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>

<body><div id="MathJax_Message" style="display: none;"></div>
<script src="./CS 386_ Lab Assignment 09_files/MathJax.js" id=""></script>

<center>
<h2>
CS 386: Lab Assignment 9
</h2>
(TA in charge: Anand Dhoot)
</center>

<p><b>Acknowledgement:</b> This lab assignment is based
on <a href="http://ai.berkeley.edu/tracking.html">Project
4: Ghostbusters</a>, which is a part of a recent offering of CS188
at UC Berkeley. The code and resources provided here are almost
entirely drawn from the Berkeley project. We thank the authors at
Berkeley for making their project available to the public.</p>


<p>Pacman spends his life running from ghosts, but things were not always so. Legend has it that many years ago, Pacman's great grandfather Grandpac learned to hunt ghosts for sport. However, he was blinded by his power and could only track ghosts by their banging and clanging.
</p>

<p>We continue to work with the Pacman, this time designing Pacman agents that use sensors to locate and eat invisible ghosts. You'll be locating single, stationary ghosts as well as hunting down packs of multiple moving ghosts.
</p>

<br>
<div align="center" style="float:CENTER; margin:0 15px 5px 0;">
    <img src="./CS 386_ Lab Assignment 09_files/busters.png" alt="Ghostbusters">
</div>
<!-- <p align="center">
An artificial neural network with 3 hidden layers <br />
<font size="1">(Image source: http://neuralnetworksanddeeplearning.com/images/tikz41.png)</font>
</p>
 -->
<br>

<h3>Code</h3> 
<p>Much of the code (and this assignment) is courtesy of <a href="http://ai.berkeley.edu/">UC Berkeley's Pacman AI projects</a>. The base code for this assignment is available in <a href="https://www.cse.iitb.ac.in/~shivaram/teaching/cs344+386-s2017/resources/la-9/tracking.zip">this zip file</a>. Here is the list of files present in the <code>tracking</code> directory. </p>

 <table style="width:100%">

  <tbody><tr>
    <td colspan="2"><b>Files you will edit</b></td>
  </tr>
  <tr>
    <td>bustersAgents.py</td>
    <td>Agents for playing the Ghostbusters variant of Pacman.</td>
  </tr>
  <tr>
    <td>inference.py</td>
    <td>Code for tracking ghosts over time using their sounds.</td>
  </tr>
  <tr>
    <td colspan="2"><b>&nbsp;</b></td>
  </tr>
  <tr>
    <td colspan="2"><b>Files you must not edit</b></td>
  </tr>
  <tr>
    <td>busters.py</td>
    <td>The main entry to Ghostbusters (replacing Pacman.py)</td>
  </tr>
  <tr>
    <td>bustersGhostAgents.py</td>
    <td>New ghost agents for Ghostbusters</td>
  </tr>
  <tr>
    <td>distanceCalculator.py</td>
    <td>Computes maze distances</td>
  </tr>
  <tr>
    <td>game.py</td>
    <td>Inner workings and helper classes for Pacman</td>
  </tr>
  <tr>
    <td>ghostAgents.py</td>
    <td>Agents to control ghosts</td>
  </tr>
  <tr>
    <td>graphicsDisplay.py</td>
    <td>Graphics for Pacman</td>
  </tr>
  <tr>
    <td>graphicsUtils.py</td>
    <td>Support for Pacman graphics</td>
  </tr>
  <tr>
    <td>keyboardAgents.py</td>
    <td>Keyboard interfaces to control Pacman</td>
  </tr>
  <tr>
    <td>layout.py</td>
    <td>Code for reading layout files and storing their contents</td>
  </tr>
  <tr>
    <td>util.py</td>
    <td>Utility functions</td>
  </tr>

</tbody></table>
<br>




<h3>Task 0: Introduction to Ghostbusters (Ungraded)</h3> 
<p>In this version of Ghostbusters, the goal is to hunt down scared but invisible ghosts. Pacman, ever resourceful, is equipped with sonar (ears) that provides noisy readings of the Manhattan distance to each ghost. The game ends when Pacman has eaten all the ghosts. To start, try playing a game yourself using the keyboard. Start the game using this command.</p>

<code>python busters.py</code>

<p>The blocks of color indicate where the each ghost could possibly be, given the noisy distance readings provided to Pacman. The noisy distances at the bottom of the display are always non-negative, and always within 7 of the true distance. The probability of a distance reading decreases exponentially with its difference from the true distance.</p>

<p>Your primary task in this assignment is to implement inference (identifying the possible squares where ghosts could be located) to track the ghosts. For the keyboard based game above, a crude form of inference was implemented for you by default: all squares in which a ghost could possibly be are shaded by the color of the ghost. Naturally, we want a better estimate of the ghost's position. </p>

<p></p><h4>Note</h4>
<ul>
<li>
Most of the boilerplate code has already been written for you so that you can focus on the crux of probabilistic inference. Go through the comments before writing code in functions specified for detailed descriptions of built-in functions and other details about the code. 
</li>
<li>
While watching and debugging your code with the autograder, it will be helpful to have some understanding of what the autograder is doing. There are 2 types of tests in this project, as differentiated by their <code>*.test</code> files found in the subdirectories of the <code>test_cases</code> folder. For tests of class <code>DoubleInferenceAgentTest</code>, your will see visualizations of the inference distributions generated by your code, but all Pacman actions will be preselected according to the actions of our implementation. This is necessary in order to allow comparision of your distributions with our distributions. The second type of test is <code>GameScoreTest</code>, in which your <code>BustersAgent</code> will actually select actions for Pacman and you will watch your Pacman play and win games.<p></p>

<p>As you implement and debug your code, you may find it useful to run a single test at a time. In order to do this you will need to use the -t flag with the autograder. For example if you only want to run the first test of question 1, use the following command.</p>

<code>python autograder.py -t test_cases/q1/1-ExactObserve</code>

<p>In general, all test cases can be found inside test_cases/q*.</p>
</li>
</ul>

<h4>Descriptions of Solutions</h4>

<p>You will be evaluated on three tasks as a part of this
assignment. In each case your code will have to clear the tests
presented by the autograder. Additionally, create a text file
called <code>descriptions.txt</code> and fill it with an informative
description of the approach you used to solve each task. We need to be
assured that you have understood the underlying concept, and are not
merely going through the motions of "applying a formula". If your
descriptions are not clear, you may lose marks for the corresponding
tasks.</p>


<h3>Task 1: Exact Inference Observation (3 marks)</h3> 

<p>In this question, you will update the <code>observe</code> method in <code>ExactInference</code> class of <code>inference.py</code> to correctly update the agent's belief distribution over ghost positions given an observation from Pacman's sensors. A correct implementation should also handle one special case: when a ghost is eaten, you should place that ghost in its prison cell, as described in the comments of <code>observe</code>.</p>

<p>Run the autograder for this question and visualize the output.</p>
<code>python autograder.py -q q1</code>

<p>As you watch the test cases, be sure that you understand how the squares converge to their final coloring. In test cases where is Pacman boxed in (which is to say, he is unable to change his observation point), why does Pacman sometimes have trouble finding the exact location of the ghost?</p>

<p><em>Note:</em> your busters agents have a separate inference module for each ghost they are tracking. That's why if you print an observation inside the <code>observe</code> function, you'll only see a single number even though there may be multiple ghosts on the board.</p>

<p><b>Hints</b></p>
<ul>
  <li>You are implementing the online belief update for observing new evidence. Before any readings, Pacman believes the ghost could be anywhere: a uniform prior (see <code>initializeUniformly</code>). After receiving a reading, the <code>observe</code> function is called, which must update the belief at every position.</li>
  <li>Before typing any code, write down the equation of the inference problem you are trying to solve.</li>
  <li>Try printing <code>noisyDistance</code>, <code>emissionModel</code>, and <code>PacmanPosition</code> (in the <code>observe</code> function) to get started.</li>
  <li>In the Pacman display, high posterior beliefs are represented by bright colors, while low beliefs are represented by dim colors. You should start with a large cloud of belief that shrinks over time as more evidence accumulates.</li>
  <li>Beliefs are stored as <code>util.Counter</code> objects (like dictionaries) in a field called <code> self.beliefs</code>, which you should update.</li>
  <li>You should not need to store any evidence. The only thing you need to store in <code>ExactInference</code> is <code>self.beliefs</code>.</li>
</ul>




<h3>Task 2: Exact Inference with Time Elapse (4 marks)</h3> 

<p>In the previous question you implemented belief updates for Pacman based on his observations. Fortunately, Pacman's observations are not his only source of knowledge about where a ghost may be. Pacman also has knowledge about the ways that a ghost may move; namely that the ghost can not move through a wall or more than one space in one timestep.</p>

<p>To understand why this is useful to Pacman, consider the following scenario in which there is Pacman and one Ghost. Pacman receives many observations which indicate the ghost is very near, but then one which indicates the ghost is very far. The reading indicating the ghost is very far is likely to be the result of a buggy sensor. Pacman's prior knowledge of how the ghost may move will decrease the impact of this reading since Pacman knows the ghost could not move so far in only one move.</p>

<p>In this question, you will implement the <code>elapseTime</code> method in <code>ExactInference</code>. Your agent has access to the action distribution for any <code>GhostAgent</code>. In order to test your <code>elapseTime</code> implementation separately from your <code>observe</code> implementation in the previous question, this question will not make use of your <code>observe</code> implementation.</p>

<p>Since Pacman is not utilizing any observations about the ghost, this means that Pacman will start with a uniform distribution over all spaces, and then update his beliefs according to how he knows the Ghost is able to move. Since Pacman is not observing the ghost, this means the ghost's actions will not impact Pacman's beliefs. Over time, Pacman's beliefs will come to reflect places on the board where he believes ghosts are most likely to be given the geometry of the board and what Pacman already knows about their valid movements.</p>

<p>For the tests in this question we will sometimes use a ghost with random movements and other times we will use the GoSouthGhost. This ghost tends to move south so over time, and without any observations, Pacman's belief distribution should begin to focus around the bottom of the board. To see which ghost is used for each test case you can look in the .test files.</p>

<p>To run the autograder for this question and visualize the output, use this command.</p>
<code>python autograder.py -q q2</code>

<p>As an example of the GoSouthGhostAgent, you can run</p>
<code>python autograder.py -t test_cases/q2/2-ExactElapse</code>

<p>and observe that the distribution becomes concentrated at the bottom of the board.</p>

<p>As you watch the autograder output, remember that lighter squares indicate that pacman believes a ghost is more likely to occupy that location, and darker squares indicate a ghost is less likely to occupy that location. For which of the test cases do you notice differences emerging in the shading of the squares? Can you explain why some squares get lighter and some squares get darker?</p>

<p><b>Hints</b></p>
<ul>
  <li>Instructions for obtaining a distribution over where a ghost will go next, given its current position and the <code>gameState</code>, appears in the comments of <code>ExactInference.elapseTime</code> in <code>inference.py</code>.</li>
  <li>We assume that ghosts still move independently of one another, so while you can develop all of your code for one ghost at a time, adding multiple ghosts should still work correctly.</li>
</ul>






<h3>Task 3: Exact Inference Full Test (3 marks)</h3>
<p>Now that Pacman knows how to use both his prior knowledge and his observations when figuring out where a ghost is, he is ready to hunt down ghosts on his own. This question will use your <code>observe</code> and <code>elapseTime</code> implementations together, along with a simple greedy hunting strategy which you will implement for this question. In the simple greedy strategy, Pacman assumes that each ghost is in its most likely position according to its beliefs, then moves toward the closest ghost. Up to this point, Pacman has moved by randomly selecting a valid action.</p>

<p>Implement the <code>chooseAction</code> method in <code>GreedyBustersAgent</code> in <code>bustersAgents.py</code>. Your agent should first find the most likely position of each remaining (uncaptured) ghost, then choose an action that minimizes the distance to the closest ghost. If correctly implemented, your agent should win the game in <code>q3/3-gameScoreTest</code> with a score greater than 700 at least 8 out of 10 times. <em>Note:</em> the autograder will also check the correctness of your inference directly, but the outcome of games is a reasonable sanity check.</p>

<p>Run the autograder for this question and visualize the output.</p>
<code>python autograder.py -q q3</code>

<p><i>Note:</i> If you want to run this test (or any of the other tests) without graphics you can add an appropriate flag, as below.</p>
<code>python autograder.py -q q3 --no-graphics</code>

<p><b>Hints</b></p>
<ul>
  <li>When correctly implemented, your agent will thrash around a bit in order to capture a ghost.</li>
  <li>The comments of <code>chooseAction</code> provide you with useful method calls for computing maze distance and successor positions.</li>
  <li>Make sure to only consider the living ghosts, as described in the comments.</li>
</ul>




<h3>Submission</h3> 
<p>You're not done yet! Place all files which you've written code in or modified in a directory named 'la9-' appended by your roll number (say la9-12345678). Tar and Gzip the directory to produce a single compressed file (la9-12345678.tar.gz). It must contain the following files: </p>
<ol>
  <li><code>bustersAgents.py       </code></li>
  <li><code>inference.py           </code></li>
  <li><code>descriptions.txt          </code></li>
  <li><code>citations.txt          </code> (if applicable)</li>
  <li>Any other file that you have modified or created to solve this assignment</li>
</ol>

<p>Submit this compressed file on Moodle, under Lab Assignment 09.</p>
</body></html>