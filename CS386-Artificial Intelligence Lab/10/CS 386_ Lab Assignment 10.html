
<!-- saved from url=(0100)https://www.cse.iitb.ac.in/~shivaram/teaching/cs344+386-s2017/resources/la-10/lab-assignment-10.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<link rel="stylesheet" type="text/css" href="./CS 386_ Lab Assignment 10_files/style.css">
<title>CS 386: Lab Assignment 10</title>
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>

<body><div id="MathJax_Message" style="display: none;"></div>
<script src="./CS 386_ Lab Assignment 10_files/MathJax.js" id=""></script>

<center>
<h2>
CS 386: Lab Assignment 10
</h2>
(TA in charge: Anand Dhoot)
</center>

<p><b>Acknowledgement:</b> This lab assignment is based
on <a href="http://ai.berkeley.edu/tracking.html">Project
4: Ghostbusters</a>, which is a part of a recent offering of CS188
at UC Berkeley. The code and resources provided here are almost
entirely drawn from the Berkeley project. We thank the authors at
Berkeley for making their project available to the public.</p>


<p>We continue where we left off last week: implementing inference to identify the (approximate) location of ghosts in the game of Ghostbusters. In this assignment, we will focus on implementing algorithms for performing inference using Particle Filters and Dynamic Bayes Nets.</p>

<br>
<div align="center" style="float:CENTER; margin:0 15px 5px 0;">
    <img src="./CS 386_ Lab Assignment 10_files/busters.png" alt="Ghostbusters">
</div>
<br>

<h3>Code</h3> 
<p>The base code for this assignment is available in <a href="https://www.cse.iitb.ac.in/~shivaram/teaching/cs344+386-s2017/resources/la-10/tracking.zip">this zip file</a>. Here is the list of files present in the <code>tracking</code> directory. </p>

 <table style="width:100%">

  <tbody><tr>
    <td colspan="2"><b>Files you will edit</b></td>
  </tr>
  <tr>
    <td>inference.py</td>
    <td>Code for tracking ghosts over time using their sounds</td>
  </tr>
  <tr>
    <td colspan="2"><b>&nbsp;</b></td>
  </tr>
  <tr>
    <td colspan="2"><b>Files you must not edit</b></td>
  </tr>
  <tr>
    <td>busters.py</td>
    <td>The main entry to Ghostbusters (replacing Pacman.py)</td>
  </tr>
  <tr>
    <td>bustersAgents.py</td>
    <td>Agents for playing the Ghostbusters variant of Pacman</td>
  </tr>
  <tr>
    <td>bustersGhostAgents.py</td>
    <td>New ghost agents for Ghostbusters</td>
  </tr>
  <tr>
    <td>distanceCalculator.py</td>
    <td>Computes maze distances</td>
  </tr>
  <tr>
    <td>game.py</td>
    <td>Inner workings and helper classes for Pacman</td>
  </tr>
  <tr>
    <td>ghostAgents.py</td>
    <td>Agents to control ghosts</td>
  </tr>
  <tr>
    <td>graphicsDisplay.py</td>
    <td>Graphics for Pacman</td>
  </tr>
  <tr>
    <td>graphicsUtils.py</td>
    <td>Support for Pacman graphics</td>
  </tr>
  <tr>
    <td>keyboardAgents.py</td>
    <td>Keyboard interfaces to control Pacman</td>
  </tr>
  <tr>
    <td>layout.py</td>
    <td>Code for reading layout files and storing their contents</td>
  </tr>
  <tr>
    <td>util.py</td>
    <td>Utility functions</td>
  </tr>

</tbody></table>
<br>


<h3>Task 0: Introduction to Ghostbusters (Ungraded)</h3> 

<p>As described in <a href="https://www.cse.iitb.ac.in/~shivaram/teaching/cs344+386-s2017/resources/la-9/lab-assignment-9.html">Lab Assignment 9</a>, in this version of Ghostbusters, the goal is to hunt down scared but invisible ghosts. The Pacman is equipped with sonar (ears) that provides noisy readings of the Manhattan distance to each ghost. The game ends when Pacman has eaten all the ghosts. Your primary task in this assignment is to implement inference (identifying the possible squares where ghosts could be located) to track the ghosts.</p>

<p></p><h4>Note</h4>
<ul>
<li>This assignment is relatively long. Make sure you keep moving along. If you haven't finished tasks 1 and 2 at the end of 90 minutes, you might not be able to finish all four tasks in the allotted 180 minutes.</li>
<li>
Most of the boilerplate code has already been written for you so that you can focus on the crux of probabilistic inference. Go through the comments before writing code in functions specified for detailed descriptions of built-in functions and other details about the code. 
</li>
<li>
While watching and debugging your code with the autograder, it will be helpful to have some understanding of what the autograder is doing. There are two types of tests in this project, as differentiated by their <code>*.test</code> files found in the subdirectories of the <code>test_cases</code> folder. For tests of class <code>DoubleInferenceAgentTest</code>, your will see visualisations of the inference distributions generated by your code, but all Pacman actions will be preselected according to the actions of our implementation. This is necessary in order to allow comparison of your distributions with our distributions. The second type of test is <code>GameScoreTest</code>, in which your <code>BustersAgent</code> will actually select actions for Pacman and you will watch your Pacman play and win games.<p></p>

<p>As you implement and debug your code, you may find it useful to run a single test at a time. In order to do this you will need to use the -t flag with the autograder. For example if you only want to run the first test of Task 1, use the following command.</p>

<code>python autograder.py -t test_cases/q1/1-ParticleObserve</code>

<p>In general, all test cases can be found inside test_cases/q*.</p>
</li>
</ul>

<h4>Descriptions of Solutions</h4>

<p>You will be evaluated on four tasks as a part of this
assignment. In each case your code will have to clear the tests
presented by the autograder. Additionally, create a text file
called <code>descriptions.txt</code> and fill it with an informative
description of the approach you used to solve each task. We need to be
assured that you have understood the underlying concept, and are not
merely going through the motions of "applying a formula". If your
descriptions are not clear, you may lose marks for the corresponding
tasks.</p>



<h3>Task 1: Approximate Inference Observation (4 marks)</h3>
<p>In this task, you will implement a particle filtering algorithm for tracking a single ghost.</p>
<p>Implement the functions <code>initializeUniformly</code>, <code>getBeliefDistribution</code>, and <code>observe</code> for the <code>ParticleFilter</code> class in <code>inference.py</code>. A correct implementation should also handle two special cases. 
</p><ol>
  <li>When all your particles receive zero weight based on the evidence, you should resample all particles from the prior to recover. </li>
  <li>When a ghost is eaten, you should update all particles to place that ghost in its prison cell, as described in the comments of <code>observe</code>. When complete, you should be able to track ghosts nearly as effectively as with exact inference.</li>
</ol><p></p>
<p>Run the autograder for this question as follows and visualise the output.</p>
<code>python autograder.py -q q1</code>

<h4>Hints</h4>
<ul>
  <li>A particle (sample) is a ghost position in this inference problem.</li>
  <li>The belief cloud generated by a particle filter will look noisy compared to the one for exact inference (the one in the previous assignment).</li>
  <li><code>util.sample</code> or <code>util.nSample</code> will help you obtain samples from a distribution. It is preferable that you use <code>util.sample</code>. If, however, your implementation is timing out, try using <code>util.nSample</code>, which needs to be called in a slightly different way from <code>util.sample</code> (see <code>util.py</code> for its definition).</li>
</ul>


<h3>Task 2: Approximate Inference with Time Elapse (3 marks)</h3>
<p>Implement the <code>elapseTime</code> function for the <code>ParticleFilter</code> class in <code>inference.py</code>. When complete, you should be able to track ghosts nearly as effectively as with exact inference.</p>
<p>Note that in this question, we will test both the <code>elapseTime</code> function in isolation, as well as the full implementation of the particle filter combining <code>elapseTime</code> and <code>observe</code>.</p>
<p>Run the autograder for this question and visualise the output.</p>
<code>python autograder.py -q q2</code>
<p>For the tests in this question we will sometimes use a ghost with random movements and other times we will use the GoSouthGhost. This ghost tends to move south so over time, and without any observations, Pacman's belief distribution should begin to focus around the bottom of the board. To see which ghost is used for each test case you can look in the .test files. As an example, you can run</p>
<code>python autograder.py -t test_cases/q2/2-ParticleElapse</code>
<p>and observe that the distribution becomes concentrated at the bottom of the board.</p>


<h3>Task 3: Joint Particle Filter Observation (5 marks)</h3>
<p>So far, we have tracked each ghost independently, which works fine for the default <code>RandomGhost</code> or more advanced <code>DirectionalGhost</code>. However, the prized <code>DispersingGhost</code> chooses actions that avoid other ghosts. Since the ghosts' transition models are no longer independent, all ghosts must be tracked jointly in a Dynamic Bayes Net!</p>
<p>The Bayes net has the following structure, where the hidden variables G represent ghost positions and the emission variables E are the noisy distances to each ghost. This structure can be extended to more ghosts, but only two (a and b) are shown below.</p>
<center><img src="./CS 386_ Lab Assignment 10_files/dbn.png" width="500px"></center>
<p>You will now implement a particle filter that tracks multiple ghosts simultaneously. Each particle will represent a <i>tuple</i> of ghost positions that is a sample of where all the ghosts are at the present time. The code is already set up to extract marginal distributions about each ghost from the joint inference algorithm you will create, so that belief clouds about individual ghosts can be displayed.</p>
<p>Complete the <code>initializeParticles</code>, <code>getBeliefDistribution</code>, and <code>observeState</code> methods in <code>JointParticleFilter</code> to weight and resample the whole list of particles based on new evidence. As before, a correct implementation should also handle two special cases. 
</p><ol>
  <li>When all your particles receive zero weight based on the evidence, you should resample all particles from the prior to recover.</li> 
  <li>When a ghost is eaten, you should update all particles to place that ghost in its prison cell, as described in the comments of <code>observeState</code>.</li>
</ol>
<p></p>
<p>You should now effectively track dispersing ghosts. To run the autograder for this question and visualize the output, use this command.</p>
<code>python autograder.py -q q3</code>


<h3>Task 4: Joint Particle Filter with Elapse Time (3 marks)</h3>
<p>Complete the <code>elapseTime</code> method in <code>JointParticleFilter</code> in <code>inference.py</code> to resample each particle correctly for the Bayes Net. In particular, each ghost should draw a new position conditioned on the positions of all the ghosts at the previous time step. The comments in the method provide instructions for support functions to help with sampling and creating the correct distribution.</p>
<p>Note that these questions involve joint distributions and they require more computational power (and time) to grade, so please be patient!</p>
<p>As you run the autograder note that <code>q4/1-JointParticleElapse</code> and <code>q4/2-JointParticleElapse</code> test your <code>elapseTime</code> implementations only, and <code>q4/3-JointParticleElapse</code> tests both your <code>elapseTime</code> and <code>observe</code> implementations. Notice the difference between test 1 and test 3. In both tests, Pacman knows that the ghosts will move to the sides of the gameboard. What is different between the tests, and why?</p>
<center><img src="./CS 386_ Lab Assignment 10_files/disperse.png" width="500px"></center>
<p>To run the autograder for this question use this command.</p>
<code>python autograder.py -q q4</code>




<h3>Submission</h3> 
<p>You're not done yet! Place all files which you've written code in or modified in a directory named 'la10-' appended by your roll number (say la10-12345678). Tar and Gzip the directory to produce a single compressed file (la10-12345678.tar.gz). It must contain the following files: </p>
<ol>
  <li><code>inference.py           </code></li>
  <li><code>descriptions.txt          </code></li>
  <li><code>citations.txt          </code> (if applicable)</li>
  <li>Any other file that you have modified or created to solve this assignment</li>
</ol>

<p>Submit this compressed file on Moodle, under Lab Assignment 10.</p>
</body></html>